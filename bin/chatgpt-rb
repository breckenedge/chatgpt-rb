#!/usr/bin/env ruby

require "dotenv/load"
require "colorize"
require "reline"
require "optparse"
require_relative "./../lib/chatgpt_rb"

begin
  stty_save = `stty -g`.chomp
rescue
end

options = {
  key: ENV["OPEN_AI_KEY"],
  model: "gpt-3.5-turbo",
  base_uri: "https://api.openai.com/v1",
  functions_files: [],
}

OptionParser.new do |opts|
  opts.banner = "Usage: chatgpt-rb [options]"

  opts.on("-f", "--file FILE", "Load a previous conversation from FILE") do |file|
    options[:file] = file
  end

  opts.on("-k", "--api-key KEY", "Use the provided API key for authentication") do |key|
    options[:key] = key
  end

  opts.on("-m", "--model MODEL", "Use the provided MODEL (Default: #{options[:model]})") do |model|
    options[:model] = model
  end

  opts.on("-b", "--base-uri URI", "Use the provided base URI (Default: #{options[:base_uri]})") do |uri|
    options[:base_uri] = uri
  end

  opts.on("-u", "--functions-file FILE", "Add functions defined in FILE to your conversation") do |functions_file|
    options[:functions_files] << functions_file
  end

  opts.on("-p", "--prompt PROMPT", "Declare the PROMPT for your conversation") do |prompt|
    options[:prompt] = prompt
  end
end.parse!

begin
  puts "Type any message to talk with ChatGPT. Type '\\help' for a list of commands."

  functions = options[:functions_files].map do |function_file|
              puts "Loading functions from #{function_file}"

              ChatgptRb::DSL::Conversation.new(ChatgptRb::Conversation.new).instance_eval(File.read(function_file))
            end

  messages = if options[:file]
               JSON.parse(File.read(options[:file])).map { |hash| hash.transform_keys(&:to_sym) }
             else
               []
             end

  if options[:prompt]
    puts "prompt> ".colorize(:blue) + options[:prompt]
  end

  conversation = ChatgptRb::Conversation.new(api_key: options.fetch(:key), model: options.fetch(:model), base_uri: options.fetch(:base_uri), messages:, functions:, prompt: options[:prompt])

  while message = Reline.readline("me> ".colorize(:red), true) do
    case message.chomp
    when "\\help", "\\h"
      puts <<~COMMANDS.colorize(:blue)
        - `\\quit` Exit
        - `\\save <filename>` Save this conversation to a JSON file that can be reloaded later with the `-f` argument
        - `\\functions` Get a list of configured functions
      COMMANDS
    when "\\q", "\\quit", "\\exit"
      exit
    when "\\dump"
      puts "dump> ".colorize(:blue) + conversation.messages.to_json
    when "\\functions"
      puts "available functions:".colorize(:blue)
      functions.each do |function|
        puts "- `#{function.name}` #{function.description}".colorize(:blue)
      end
    when /^\\save .+/
      filename = /^\\save (.+)/.match(message)[1]
      File.open(filename, "w") { |f| f.write(conversation.messages.to_json) }
      puts "saved to #{filename} ".colorize(:blue)
    else
      print("ai> ".colorize(:yellow))
      conversation.ask(message) { |fragment| print(fragment) }
      puts
    end
  end
rescue Interrupt
  puts "^C"
  `stty #{stty_save}` if stty_save
  exit
end
