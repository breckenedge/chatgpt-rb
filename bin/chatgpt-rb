#!/usr/bin/env ruby

require "dotenv/load"
require "colorize"
require "reline"
require "optparse"
require_relative "./../lib/chatgpt_rb"

begin
  stty_save = `stty -g`.chomp
rescue
end

options = {
  key: ENV["OPEN_AI_KEY"],
  model: "gpt-3.5-turbo",
  base_uri: "https://api.openai.com/v1",
}

OptionParser.new do |opts|
  opts.banner = "Usage: chatgpt-rb [options]"

  opts.on("-f", "--file FILE", "Load a previous conversation from FILE") do |file|
    options[:file] = file
  end

  opts.on("-k", "--api-key KEY", "Use the provided API key for authentication") do |key|
    options[:key] = key
  end

  opts.on("-m", "--model MODEL", "Use the provided MODEL") do |model|
    options[:model] = model
  end

  opts.on("-b", "--base-uri URI", "Use the provided base URI") do |uri|
    options[:base_uri] = uri
  end
end.parse!

begin
  puts "Type any message to talk with ChatGPT. Type 'exit' to quit. Type 'save <filename>' to save this conversation to a JSON file that can be reloaded later with the `-f` argument."

  messages = if options[:file]
               JSON.parse(File.read(options[:file])).map { |hash| hash.transform_keys(&:to_sym) }
             else
               []
             end

  conversation = ChatgptRb::Conversation.new(api_key: options.fetch(:key), model: options.fetch(:model), base_uri: options.fetch(:base_uri), messages:)

  while message = Reline.readline("me> ".colorize(:red), true) do
    case message.chomp
    when "exit", "quit", "q", "\\q"
      exit
    when "dump"
      puts "dump> ".colorize(:blue) + conversation.messages.to_json
    when /save .+/
      filename = /save (.+)/.match(message)[1]
      File.open(filename, "w") { |f| f.write(conversation.messages.to_json) }
      puts "saved to #{filename} ".colorize(:blue)
    else
      print("ai> ".colorize(:yellow))
      conversation.ask(message) { |fragment| print(fragment) }
      puts
    end
  end
rescue Interrupt
  puts "^C"
  `stty #{stty_save}` if stty_save
  exit
end
